/*
* (C) 2021 Jack Lloyd
* (C) 2021 Ren√© Meusel
*
* Botan is released under the Simplified BSD License (see license.txt)
*/

#include "tests.h"
#include <memory>
// Since RFC 8448 uses a specific set of cipher suites we can only run this
// test if all of them are enabled.
#if defined(BOTAN_HAS_TLS_13) && \
    defined(BOTAN_HAS_AEAD_CHACHA20_POLY1305) && \
    defined(BOTAN_HAS_AEAD_GCM) && \
    defined(BOTAN_HAS_AES) && \
    defined(BOTAN_HAS_SHA2_32) && \
    defined(BOTAN_HAS_SHA2_64)
#define BOTAN_CAN_RUN_TEST_TLS_RFC8448
#endif

#if defined(BOTAN_CAN_RUN_TEST_TLS_RFC8448)
  #include "test_rng.h"
  #include "test_tls_utils.h"

  #include <botan/auto_rng.h>  // TODO: replace me, otherwise we depend on auto_rng module
  #include <botan/credentials_manager.h>
  #include <botan/rsa.h>
  #include <botan/tls_alert.h>
  #include <botan/tls_callbacks.h>
  #include <botan/tls_client.h>
  #include <botan/tls_policy.h>
  #include <botan/tls_messages.h>
  #include <botan/tls_server.h>
  #include <botan/tls_server_info.h>
  #include <botan/tls_session.h>
  #include <botan/tls_session_manager.h>
  #include <botan/tls_version.h>

  #include <botan/assert.h>

  #include <botan/internal/loadstor.h>
#endif

namespace Botan_Tests {

#if defined(BOTAN_CAN_RUN_TEST_TLS_RFC8448)

namespace
{
constexpr size_t RECORD_HEADER_SIZE = 5;

template <typename Itr>
decltype(auto) slice(Itr begin, Itr end)
   {
   return std::vector<uint8_t>(begin, end);
   }

void check_record_header(Test::Result &result, const std::vector<uint8_t> &record)
   {
   const bool header_present = record.size() >= RECORD_HEADER_SIZE;
   result.confirm("record header is present", header_present);
   if (!header_present) return;

   // RFC8446 5.1
   // legacy_record_version:  MUST be set to 0x0303 for all records
   //       generated by a TLS 1.3 implementation other than an initial
   //       ClientHello (i.e., one not generated after a HelloRetryRequest),
   //       where it MAY also be 0x0301 for compatibility purposes.
   // Botan sets the version to 0x0303 also for the client hello
   result.test_eq("record version set correctly", slice(record.begin(), record.begin() + 3), Botan::hex_decode("160303"));
   const auto msg_len = Botan::load_be<uint16_t>(record.data() + 3, 0);
   const auto msg = slice(record.begin() + RECORD_HEADER_SIZE, record.end());
   result.test_eq("record has indicated length", msg.size(), msg_len);
   }

void add_entropy(Botan_Tests::Fixed_Output_RNG &rng, const std::string& hex)
   {
       std::vector<uint8_t> in = Botan::hex_decode(hex);
       rng.add_entropy(in.data(), in.size());
   }

Botan::RSA_PrivateKey server_private_key()
   {
   return
      {
      Botan::BigInt("0xE435FB7CC83737756DACEA96AB7F59A2CC1069DB7DEB190E17E33A532B273F30A327AA0AAABC58CD67466AF9845FADC675FE094AF92C4BD1F2C1BC33DD2E0515"),
      Botan::BigInt("0xCABD3BC0E0438664C8D4CC9F99977A94D9BBFEAD8E43870ABAE3F7EB8B4E0EEE8AF1D9B4719BA6196CF2CBBAEEEBF8B3490AFE9E9FFA74A88AA51FC645629303"),
      Botan::BigInt("0x010001")
      };
   }

Botan::X509_Certificate server_certificate()
   {
   // self-signed certificate with an RSA1024 public key
   //
   //   [...]
   //   Issuer: CN=rsa
   //   Validity
   //       Not Before: Jul 30 01:23:59 2016 GMT
   //       Not After : Jul 30 01:23:59 2026 GMT
   //   Subject: CN=rsa
   //   [...]
   //   X509v3 extensions:
   //        X509v3 Basic Constraints:
   //            CA:FALSE
   //        X509v3 Key Usage:
   //            Digital Signature, Key Encipherment
   //   [...]
   return Botan::X509_Certificate(
      Botan::hex_decode(
         "308201ac30820115a003020102020102300d06092a864886f70d01010b050030"
         "0e310c300a06035504031303727361301e170d3136303733303031323335395a"
         "170d3236303733303031323335395a300e310c300a0603550403130372736130"
         "819f300d06092a864886f70d010101050003818d0030818902818100b4bb498f"
         "8279303d980836399b36c6988c0c68de55e1bdb826d3901a2461eafd2de49a91"
         "d015abbc9a95137ace6c1af19eaa6af98c7ced43120998e187a80ee0ccb0524b"
         "1b018c3e0b63264d449a6d38e22a5fda430846748030530ef0461c8ca9d9efbf"
         "ae8ea6d1d03e2bd193eff0ab9a8002c47428a6d35a8d88d79f7f1e3f02030100"
         "01a31a301830090603551d1304023000300b0603551d0f0404030205a0300d06"
         "092a864886f70d01010b05000381810085aad2a0e5b9276b908c65f73a726717"
         "0618a54c5f8a7b337d2df7a594365417f2eae8f8a58c8f8172f9319cf36b7fd6"
         "c55b80f21a03015156726096fd335e5e67f2dbf102702e608ccae6bec1fc63a4"
         "2a99be5c3eb7107c3c54e9b9eb2bd5203b1c3b84e0a8b2f759409ba3eac9d91d"
         "402dcc0cc8f8961229ac9187b42b4de10000")
      );
   }

class Test_TLS_13_Callbacks : public Botan::TLS::Callbacks
   {
   public:
      void tls_emit_data(const uint8_t data[], size_t size) override
         {
         send_buffer.insert(send_buffer.end(), data, data + size);
         }

      void tls_record_received(uint64_t seq_no, const uint8_t data[], size_t size) override
         {
         BOTAN_UNUSED(seq_no, data, size);
         // process full TLS record received by tls client, e.g.,
         // by passing it to the application
         }

      void tls_alert(Botan::TLS::Alert alert) override
         {
         BOTAN_UNUSED(alert);
         // handle a tls alert received from the tls server
         }

      bool tls_session_established(const Botan::TLS::Session& session) override
         {
         BOTAN_UNUSED(session);
         // the session with the tls client was established
         // return false to prevent the session from being cached, true to
         // cache the session in the configured session manager
         return false;
         }

      std::vector<uint8_t> pull_send_buffer() {
         return std::exchange(send_buffer, std::vector<uint8_t>());
      }

   private:
      std::vector<uint8_t> send_buffer;
   };

class Test_Server_Credentials : public Botan::Credentials_Manager
{
   public:
      Test_Server_Credentials() : m_key(server_private_key()) {}

      std::vector<Botan::Certificate_Store*>
      trusted_certificate_authorities(const std::string &type, const std::string &context) override
         {
         BOTAN_UNUSED(type, context);
         return {};
         }

      std::vector<Botan::X509_Certificate> cert_chain(
         const std::vector<std::string>& cert_key_types,
         const std::string& type,
         const std::string& context) override
         {
         BOTAN_UNUSED(cert_key_types, type, context);
         return { server_certificate() };
         }

      Botan::Private_Key* private_key_for(const Botan::X509_Certificate& cert,
         const std::string& type,
         const std::string& context) override
         {
         BOTAN_UNUSED(cert, type, context);
         // return the private key associated with the leaf certificate,
         // in this case the one associated with "botan.randombit.net.crt"
         return &m_key;
         }

   private:
      Botan::RSA_PrivateKey m_key;
};

class TLS_Context
   {
   protected:
      TLS_Context(std::unique_ptr<Botan::RandomNumberGenerator> rng_in)
         : rng(std::move(rng_in))
         , session_mgr(*rng)
         , policy(read_tls_policy("rfc8448"))
         {}

   public:
      std::vector<uint8_t> pull_send_buffer() {
         return callbacks.pull_send_buffer();
      }

   public:
      Test_TLS_13_Callbacks   callbacks;
      Test_Server_Credentials creds;

      std::unique_ptr<Botan::RandomNumberGenerator> rng;
      Botan::TLS::Session_Manager_In_Memory         session_mgr;
      Botan::TLS::Text_Policy                       policy;
   };

class Server_Context : public TLS_Context
   {
   public:
      Server_Context(std::unique_ptr<Botan::RandomNumberGenerator> rng_in)
         : TLS_Context(std::move(rng_in))
         , server(callbacks, session_mgr, creds, policy, *rng)
         {}

      Botan::TLS::Server server;
   };

class Client_Context : public TLS_Context
   {
   public:
      Client_Context(std::unique_ptr<Botan::RandomNumberGenerator> rng_in)
         : TLS_Context(std::move(rng_in))
         , client(callbacks, session_mgr, creds, policy, *rng,
                  Botan::TLS::Server_Information("server"),
                  Botan::TLS::Protocol_Version::TLS_V13)
         {}

      Botan::TLS::Client client;
   };
}

class Test_TLS_RFC8448 final : public Test
   {
   private:
      Test::Result simple_1_rtt_client_hello()
         {
         Test::Result result("Simple 1-RTT (Client side)");

         // TODO: fixed output RNG is probably not needed as we cannot get the "right"
         //       client hello anyway -- revert
         auto rng = std::make_unique<Botan_Tests::Fixed_Output_RNG>("");
         rng->add_entropy(std::vector<uint8_t>(32).data(), 32);  // used by session mgr for session key
         add_entropy(*rng, "cb34ecb1e78163ba1c38c6dacb196a6dffa21a8d9912ec18a2ef6283024dece7");

         rng->add_entropy(std::vector<uint8_t>(1024).data(), 1024);

         Client_Context ctx(std::move(rng));
         result.confirm("client not closed", !ctx.client.is_closed());

         const auto client_hello_record = ctx.pull_send_buffer();
         result.test_gte("client hello received", client_hello_record.size(), RECORD_HEADER_SIZE);

         check_record_header(result, client_hello_record);
         const auto client_hello_msg = slice(client_hello_record.begin() + RECORD_HEADER_SIZE, client_hello_record.end());


         const auto expected_hello = Botan::hex_decode(
           "16 03 01 00 c4 01 00 00 c0 03 03 cb"
           "34 ec b1 e7 81 63 ba 1c 38 c6 da cb 19 6a 6d ff a2 1a 8d 99 12"
           "ec 18 a2 ef 62 83 02 4d ec e7 00 00 06 13 01 13 03 13 02 01 00"
           "00 91 00 00 00 0b 00 09 00 00 06 73 65 72 76 65 72 ff 01 00 01"
           "00 00 0a 00 14 00 12 00 1d 00 17 00 18 00 19 01 00 01 01 01 02"
           "01 03 01 04 00 23 00 00 00 33 00 26 00 24 00 1d 00 20 99 38 1d"
           "e5 60 e4 bd 43 d2 3d 8e 43 5a 7d ba fe b3 c0 6e 51 c1 3c ae 4d"
           "54 13 69 1e 52 9a af 2c 00 2b 00 03 02 03 04 00 0d 00 20 00 1e"
           "04 03 05 03 06 03 02 03 08 04 08 05 08 06 04 01 05 01 06 01 02"
           "01 04 02 05 02 06 02 02 02 00 2d 00 02 01 01 00 1c 00 02 40 01");

         result.test_eq("TLS client hello", client_hello_record, expected_hello);

         // RFC8446 5.1
         // legacy_record_version:  MUST be set to 0x0303 for all records
         //       generated by a TLS 1.3 implementation other than an initial
         //       ClientHello (i.e., one not generated after a HelloRetryRequest),
         //       where it MAY also be 0x0301 for compatibility purposes.
         result.test_eq("TLS client hello header",
                        slice(client_hello_msg.begin(), client_hello_msg.begin() + 1),
                        Botan::hex_decode("01"));

         auto client_hello_length_bytes = slice(client_hello_msg.begin() + 1, client_hello_msg.begin() + 4);
         client_hello_length_bytes.insert(client_hello_length_bytes.begin(), '\x00');
         const auto indicated_hello_length = Botan::load_be<uint32_t>(client_hello_length_bytes.data(), 0);

         const auto client_hello = slice(client_hello_msg.begin() + 4, client_hello_msg.end());
         result.test_eq("TLS client hello has indicated length",
                        client_hello.size(),
                        indicated_hello_length);

         Botan::TLS::Client_Hello hello(client_hello);
         result.test_eq("only one supported version", hello.supported_versions().size(), 1);
         result.test_int_eq("Supported Version is 1.3",
                            hello.supported_versions().front().version_code(),
                            Botan::TLS::Protocol_Version::TLS_V13);

         // ----

         // header
         //   type: handshake, version: Tls12, len: 90
         // message
         //   version: Tls12, rand_time: 2796488356, rand_data: [...],
         //   session_id: None, cipher: 0x1301(AES_128_GCM_SHA256),
         //   compression: Null, ext: [...]
         const auto server_hello = Botan::hex_decode(
           "16 03 03 00 5a 02 00 00 56 03 03 a6"
           "af 06 a4 12 18 60 dc 5e 6e 60 24 9c d3 4c 95 93 0c 8a c5 cb 14"
           "34 da c1 55 77 2e d3 e2 69 28 00 13 01 00 00 2e 00 33 00 24 00"
           "1d 00 20 c9 82 88 76 11 20 95 fe 66 76 2b db f7 c6 72 e1 56 d6"
           "cc 25 3b 83 3d f1 dd 69 b1 b0 4e 75 1f 0f 00 2b 00 02 03 04");

         // ctx.client.received_data(server_hello);

         // to test:
         //   * server responds with cipher suite not offered by client

         return result;
         }

      Test::Result simple_1_rtt_server()
         {
         Test::Result result("Simple 1-RTT (Server side)");

         Server_Context ctx(std::make_unique<Botan::AutoSeeded_RNG>());

         // Cipher Suites in this client hello:
         //   AES_128_GCM_SHA256
         //   CHACHA20_POLY1305_SHA256
         //   AES_256_GCM_SHA384
         const auto client_hello = Botan::hex_decode(
         "16 03 01 00 c4 01 00 00 c0 03 03 cb"
         "34 ec b1 e7 81 63 ba 1c 38 c6 da cb 19 6a 6d ff a2 1a 8d 99 12"
         "ec 18 a2 ef 62 83 02 4d ec e7 00 00 06 13 01 13 03 13 02 01 00"
         "00 91 00 00 00 0b 00 09 00 00 06 73 65 72 76 65 72 ff 01 00 01"
         "00 00 0a 00 14 00 12 00 1d 00 17 00 18 00 19 01 00 01 01 01 02"
         "01 03 01 04 00 23 00 00 00 33 00 26 00 24 00 1d 00 20 99 38 1d"
         "e5 60 e4 bd 43 d2 3d 8e 43 5a 7d ba fe b3 c0 6e 51 c1 3c ae 4d"
         "54 13 69 1e 52 9a af 2c 00 2b 00 03 02 03 04 00 0d 00 20 00 1e"
         "04 03 05 03 06 03 02 03 08 04 08 05 08 06 04 01 05 01 06 01 02"
         "01 04 02 05 02 06 02 02 02 00 2d 00 02 01 01 00 1c 00 02 40 01");

         const size_t remaining = ctx.server.received_data(client_hello);

         result.test_int_eq(remaining, 0, "client hello was fully consumed");
         result.confirm("server not closed", !ctx.server.is_closed());

         const auto server_hello_record = ctx.pull_send_buffer();
         check_record_header(result, server_hello_record);

         return result;
         }

   public:
      std::vector<Test::Result> run() override
         {
         return
            {
            simple_1_rtt_client_hello()
            // simple_1_rtt_server()
            };
         }
   };

BOTAN_REGISTER_TEST("tls", "tls_rfc8448", Test_TLS_RFC8448);

#endif

}
